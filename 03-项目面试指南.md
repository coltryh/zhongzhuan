# 拜耳智能招采平台 - 项目面试指南

> 本文档帮助你将项目经验写进简历，并准备面试中可能遇到的问题。

---

## 目录

- [一、简历项目描述](#一简历项目描述)
- [二、项目亮点总结](#二项目亮点总结)
- [三、面试问题准备](#三面试问题准备)
- [四、技术深度问题](#四技术深度问题)
- [五、业务理解问题](#五业务理解问题)
- [六、项目难点与解决方案](#六项目难点与解决方案)
- [七、面试技巧](#七面试技巧)

---

## 一、简历项目描述

### 1.1 项目基本信息

```
项目名称：拜耳中国-华东区招标采购流程管理系统
项目类型：企业级B2B业务管理系统
开发周期：2024年X月 - 2024年X月（根据实际情况填写）
团队规模：X人（根据实际情况填写）
担任角色：后端开发工程师 / 全栈开发工程师
技术栈：Spring Boot 3 + Vue 3 + MySQL + AWS S3
```

### 1.2 项目描述模板（可复制到简历）

**版本一：简洁版（适合简历空间有限）**

```
拜耳智能招采平台 | 后端开发工程师

项目描述：
为拜耳中国华东区开发的医药招标采购流程管理系统，实现项目管理、资料库、价格库、产品库、
待办任务和审批流程等功能。

技术栈：
后端：Spring Boot 3.5.7、MyBatis Plus、Spring Security、JWT、MySQL
前端：Vue 3、TypeScript、Element Plus、Pinia
其他：AWS S3 文件存储、EasyExcel、OAuth2 (Azure AD)

主要工作：
• 设计并实现项目管理、产品管理、价格管理、资料管理等核心模块
• 实现 JWT + OAuth2 双重认证机制，确保系统安全
• 使用 AOP 实现操作日志记录，支持数据变更追溯
• 开发待办任务自动生成机制，与审批流程深度集成
• 实现 Excel 导入导出功能，支持批量数据处理
• 使用异步任务和定时任务优化系统性能
```

**版本二：详细版（适合详细描述）**

```
拜耳智能招采平台 | 后端开发工程师

项目背景：
为拜耳中国华东区开发的企业级医药招标采购流程管理系统，用于管理国谈、带量采购、新增挂网
等招投标业务，涉及项目管理、资料管理、价格管理、产品管理、工作流审批等核心功能。

技术架构：
• 后端：Spring Boot 3.5.7 + MyBatis Plus + MySQL + Redis
• 前端：Vue 3 + TypeScript + Element Plus + Vite
• 安全：Spring Security + JWT + OAuth2 (Azure AD SSO)
• 存储：AWS S3 对象存储
• 部署：Docker + GitHub Actions CI/CD

核心功能：
1. 项目管理模块：支持中央项目和区域项目的创建、审批、结项全流程管理
2. 产品管理模块：维护产品基础信息，支持版本管理和变更通知
3. 价格管理模块：管理各省挂网价格，支持价格导入导出和趋势分析
4. 资料管理模块：管理产品资料、企业资料、邮件资料，支持有效期自动预警
5. 审批流程模块：自定义审批流程，支持多级审批和待办任务自动生成

主要贡献：
• 设计并实现基于 Token 认证和 OAuth2 的双重认证体系，支持 Azure AD SSO 登录
• 使用 AOP + SpEL 实现操作日志记录，自动记录数据变更前后对比
• 开发基于状态机的审批流程引擎，实现待办任务自动分配和流转
• 优化文件上传下载，使用 AWS S3 对象存储，支持大文件分片上传
• 使用 @Async 和 @Scheduled 优化邮件发送和资料过期检查，提升系统性能
• 编写完善的单元测试，核心模块测试覆盖率达到 80% 以上

项目成果：
• 系统已上线运行，服务拜耳华东区 5 个省份的招标采购业务
• 处理项目数据 500+ 条，产品数据 10000+ 条，价格数据 50000+ 条
• 系统响应时间平均 < 500ms，并发支持 100+ QPS
• 通过 AOP 自动记录操作日志，数据变更可追溯
```

### 1.3 项目描述写作技巧

**✅ 好的项目描述应该包含：**

1. **项目背景**：为什么做这个项目？解决了什么问题？
2. **技术栈**：使用了哪些技术？为什么选择这些技术？
3. **核心功能**：实现了哪些功能？有什么亮点？
4. **个人贡献**：你负责了什么？解决了什么难题？
5. **量化成果**：项目取得了什么效果？（用数据说话）

**❌ 避免的错误：**

- 只列出技术栈，没有说明为什么使用
- 没有量化项目成果
- 没有说明个人贡献
- 功能描述过于简单，缺乏技术深度

---

## 二、项目亮点总结

### 2.1 技术亮点

**亮点1：双重认证机制**

```
问题：企业系统需要高安全性的认证机制
方案：JWT + OAuth2 双重认证
      • JWT Token 用于日常 API 访问
      • OAuth2 集成 Azure AD 实现企业 SSO
技术难点：
      • Token 生成、验证、刷新机制
      • OAuth2 回调处理
      • 单点登录状态同步
```

**亮点2：AOP 操作日志**

```
问题：需要记录所有数据变更操作，用于审计追溯
方案：使用 AOP + SpEL 实现自动日志记录
      • 自定义 @OperationLog 注解
      • SpEL 表达式动态获取方法参数
      • JSON Diff 自动对比数据变更
技术难点：
      • SpEL 表达式解析
      • JSON 对象深度对比
      • 事务同步（事务提交后才写日志）
```

**亮点3：审批流程引擎**

```
问题：不同业务场景需要不同的审批流程
方案：自定义状态机流程引擎
      • 流程模板定义
      • 流程节点配置
      • 待办任务自动生成
技术难点：
      • 状态机设计
      • 待办任务分配策略
      • 并发审批处理
```

**亮点4：性能优化**

```
问题：邮件发送和资料检查等耗时操作影响主流程
方案：使用异步任务和定时任务
      • @Async 异步发送邮件
      • @Scheduled 定时检查资料过期
      • 线程池配置优化
技术难点：
      • 线程池参数调优
      • 异步异常处理
      • 定时任务并发控制
```

### 2.2 业务亮点

**亮点1：智能资料预警**

```
功能：自动检查资料有效期，提前发送过期提醒
技术：
  • 定时任务每天检查资料有效期
  • 根据过期时间自动计算资料状态
  • 邮件异步发送提醒
效果：避免资料过期导致业务中断
```

**亮点2：价格趋势分析**

```
功能：支持各省价格导入和趋势分析
技术：
  • EasyExcel 批量导入价格
  • 多级表头导出
  • 价格趋势可视化
效果：帮助分析市场价格变化
```

**亮点3：待办任务自动分配**

```
功能：审批流程启动后自动生成待办任务
技术：
  • 根据角色和地区自动分配
  • 待办状态实时同步
  • 支持批量待办处理
效果：提高审批效率，减少人工操作
```

---

## 三、面试问题准备

### 3.1 项目介绍（必问）

**问题：请介绍一下你的项目**

**参考回答**：

```
我参与开发的是拜耳中国华东区的招标采购流程管理系统，这是一个企业级B2B业务管理系统。

项目背景是拜耳需要在华东区管理各种招投标业务，包括国家医保谈判、带量采购、新增挂网等。
这些业务涉及大量的项目管理、资料管理、价格管理工作，原有系统功能分散，效率低下，
所以我们开发了这个统一的管理平台。

技术栈方面，后端使用 Spring Boot 3 + MyBatis Plus，前端使用 Vue 3 + TypeScript，
数据库使用 MySQL，文件存储使用 AWS S3。

我主要负责后端开发，实现了项目管理、产品管理、价格管理、资料管理等核心模块。
其中我解决了几个关键技术难点：

1. 实现了 JWT + OAuth2 双重认证机制，支持 Azure AD SSO 登录
2. 使用 AOP 实现了操作日志自动记录，可以追溯所有数据变更
3. 开发了审批流程引擎，实现了待办任务的自动生成和分配
4. 使用异步任务优化了邮件发送等耗时操作，提升了系统性能

项目已经上线运行，目前处理了 500+ 项目数据，系统响应时间控制在 500ms 以内。
```

### 3.2 技术选型（高频）

**问题：为什么选择 Spring Boot 3？**

**参考回答**：

```
选择 Spring Boot 3 主要有以下几个原因：

1. 最新技术：Spring Boot 3 支持 Java 17，带来了性能提升和新特性
   • 启动速度提升 30%
   • 内存占用降低 20%
   • 原生支持 GraalVM

2. 生态完善：Spring Boot 生态成熟，各种 Starter 依赖开箱即用
   • Spring Security 安全认证
   • Spring Data 数据访问
   • 丰富的第三方集成

3. 开发效率：自动配置大大提高了开发效率
   • 减少了 XML 配置
   • 内嵌 Tomcat 服务器
   • 热部署支持

4. 团队经验：团队对 Spring 生态比较熟悉，可以快速上手
```

**问题：为什么选择 Vue 3 而不是 Vue 2？**

**参考回答**：

```
选择 Vue 3 主要考虑：

1. 性能提升：
   • 使用 Proxy 代替 Object.defineProperty，响应式性能更好
   • 编译时的优化，比如静态提升
   • 更小的打包体积

2. Composition API：
   • 更好的逻辑复用
   • 更好的 TypeScript 支持
   • 代码组织更灵活

3. 生态系统：
   • Element Plus 等 UI 库已经成熟
   • Vite 构建工具开发体验极佳
   • 社区活跃，问题容易解决

4. 长期考虑：
   • Vue 2 已经停止维护
   • Vue 3 是未来趋势
   • 新项目建议直接用 Vue 3
```

**问题：为什么使用 MyBatis Plus 而不是 JPA？**

**参考回答**：

```
选择 MyBatis Plus 主要原因：

1. 灵活的 SQL 控制：
   • 复杂查询可以用 XML 或注解编写
   • SQL 优化更方便
   • 适合复杂业务场景

2. MyBatis Plus 增强功能：
   • BaseMapper 提供 CRUD 方法，不需要手写
   • LambdaQueryWrapper 类型安全
   • 分页插件开箱即用
   • 代码生成器提高开发效率

3. 团队习惯：
   • 团队对 MyBatis 更熟悉
   • SQL 可读性好，便于维护

4. 性能考虑：
   • MyBatis 性能优于 JPA
   • SQL 优化空间大
   • 适合高并发场景
```

### 3.3 认证安全（高频）

**问题：如何实现用户认证？**

**参考回答**：

```
我们实现了双重认证机制：

1. JWT Token 认证：
   • 用户登录后生成 JWT Token
   • Token 包含用户基本信息和角色权限
   • 每次请求在 Header 中携带 Token
   • 后端通过拦截器验证 Token

2. OAuth2 集成：
   • 集成 Azure AD 实现企业 SSO
   • 用户点击 "Azure AD 登录"
   • 跳转到微软登录页面
   • 登录成功后回调，携带授权码
   • 后端换取 Token 并生成 JWT
   • 重定向到前端并携带 JWT

实现细节：
• 使用 jjwt 库生成和解析 JWT
• Token 有效期 24 小时
• 使用 Spring Security 配置安全规则
• 拦截器统一处理认证逻辑
```

**问题：如何保证接口安全？**

**参考回答**：

```
我们采取了多层安全措施：

1. 认证层：
   • JWT Token 认证
   • Token 过期机制
   • OAuth2 集成

2. 授权层：
   • RBAC 角色权限控制
   • 接口级别权限注解
   • 前端按钮权限控制

3. 数据层：
   • 参数校验（@Validated）
   • SQL 注入防护（MyBatis 预编译）
   • XSS 防护（前端转义）

4. 传输层：
   • HTTPS 加密传输
   • 敏感数据加密存储

5. 日志层：
   • 操作日志记录
   • 异常日志监控
```

### 3.4 性能优化（高频）

**问题：项目中有哪些性能优化？**

**参考回答**：

```
项目中我做了以下性能优化：

1. 异步处理：
   • 邮件发送使用 @Async 异步处理
   • 不阻塞主流程，提升响应速度

2. 数据库优化：
   • 添加合适的索引
   • 使用分页查询避免一次性加载大量数据
   • 优化 SQL，避免 N+1 查询

3. 缓存优化：
   • 字典数据缓存
   • 用户信息缓存
   • 减少数据库查询

4. 线程池优化：
   • 配置合理的线程池参数
   • 核心线程数：64
   • 最大线程数：2048
   • 队列容量：2048

5. 前端优化：
   • 路由懒加载
   • 组件按需加载
   • 使用 Keep-Alive 缓存组件

6. 文件上传优化：
   • 使用 AWS S3 对象存储
   • 支持大文件分片上传
   • CDN 加速下载

效果：
• 系统响应时间从 1s 降低到 500ms
• 并发支持从 50 QPS 提升到 100+ QPS
```

### 3.5 数据库设计（中频）

**问题：数据库表是如何设计的？**

**参考回答**：

```
数据库设计遵循以下原则：

1. 命名规范：
   • 表名：bidding_模块_功能，如 bidding_project
   • 字段名：小写+下划线，如 project_name
   • 索引名：idx_字段名，如 idx_project_code

2. 基础字段：
   • 每个表都有主键 id（自增）
   • create_by、create_time 创建信息
   • update_by、update_time 更新信息
   • deleted 逻辑删除标识

3. 索引设计：
   • 唯一索引：业务唯一键，如 project_code
   • 普通索引：常查询字段，如 user_id
   • 联合索引：多条件查询，如 (province, city)

4. 关联设计：
   • 一对多：外键关联，如 project_id
   • 多对多：中间表，如 material_product
   • 自关联：parent_id

5. 扩展性：
   • 预留扩展字段
   • 使用 JSON 存储非结构化数据
   • 分表策略（预留）
```

**问题：如何处理事务？**

**参考回答**：

```
事务处理主要在 Service 层：

1. @Transactional 注解：
   • 在 Service 方法上添加 @Transactional
   • 默认使用 RuntimeException 回滚
   • 可以指定 rollbackFor

2. 事务传播：
   • REQUIRED（默认）：如果当前有事务就加入，没有就创建
   • REQUIRES_NEW：总是创建新事务
   • SUPPORTS：有事务就加入，没有就以非事务执行

3. 事务隔离：
   • 使用默认的 READ_COMMITTED
   • 避免脏读、不可重复读

4. 注意事项：
   • 事务方法不要在同一个类中调用
   • 事务范围尽量小
   • 避免在事务中进行远程调用

示例：
@Transactional(rollbackFor = Exception.class)
public String saveProject(ProjectDTO dto) {
    // 1. 保存项目
    biddingProjectsMapper.insert(projectDO);

    // 2. 保存产品列表
    for (ProductDTO product : dto.getProducts()) {
        biddingProductMapper.insert(productDO);
    }

    // 3. 保存资料
    for (MaterialDTO material : dto.getMaterials()) {
        biddingMaterialMapper.insert(materialDO);
    }

    return "保存成功";
}
```

### 3.6 前端技术（中频）

**问题：Vue 3 和 Vue 2 有什么区别？**

**参考回答**：

```
Vue 3 相比 Vue 2 有以下主要区别：

1. 响应式系统：
   • Vue 2：Object.defineProperty
   • Vue 3：Proxy（性能更好）

2. API 风格：
   • Vue 2：Options API
   • Vue 3：Composition API（更灵活）

3. TypeScript 支持：
   • Vue 3 用 TypeScript 重写
   • 更好的类型推断

4. 性能：
   • Vue 3 编译优化（静态提升）
   • 更小的打包体积
   • 更快的渲染速度

5. 生命周期：
   • Vue 2：beforeCreate、created...
   • Vue 3：setup 代替 beforeCreate 和 created
   • 使用 onMounted、onUpdated 等函数

6. 组件定义：
   • Vue 2：export default {}
   • Vue 3：<script setup> 更简洁
```

**问题：如何管理前端状态？**

**参考回答**：

```
我们使用 Pinia 管理状态：

1. 为什么选择 Pinia：
   • Vue 3 官方推荐
   • 比 Vuex 更简单
   • 完整的 TypeScript 支持
   • 支持持久化插件

2. Store 结构：
   state：状态数据
   getters：计算属性
   actions：方法（支持异步）
   persist：持久化配置

3. 使用示例：
   • 定义 Store：defineStore('user', { ... })
   • 使用 Store：const userStore = useUserStore()
   • 访问状态：userStore.user
   • 调用方法：userStore.login()

4. 持久化：
   • 使用 pinia-plugin-persistedstate
   • 可以选择 localStorage 或 sessionStorage
   • 我们选择 sessionStorage，关闭浏览器自动清除
```

---

## 四、技术深度问题

### 4.1 AOP 原理（高频）

**问题：AOP 的原理是什么？项目中如何使用？**

**参考回答**：

```
AOP（面向切面编程）的核心原理：

1. 代理模式：
   • JDK 动态代理（基于接口）
   • CGLIB 代理（基于类）
   • Spring 自动选择代理方式

2. 核心概念：
   • Aspect（切面）：要实现的交叉功能
   • JoinPoint（连接点）：应用程序执行过程中的点
   • Pointcut（切点）：一组连接点的集合
   • Advice（通知）：在切点上执行的动作
   • Weaving（织入）：将切面应用到目标对象

3. 通知类型：
   • @Before：前置通知
   • @After：后置通知
   • @Around：环绕通知
   • @AfterReturning：返回通知
   • @AfterThrowing：异常通知

项目中使用 AOP 实现操作日志：

@Aspect
@Component
public class OperationLogAspect {

    @Around("@annotation(OperationLog)")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        // 1. 获取操作前数据
        Object before = getBeforeData();

        // 2. 执行业务方法
        Object result = pjp.proceed();

        // 3. 获取操作后数据
        Object after = getAfterData();

        // 4. 对比差异
        String diff = compareData(before, after);

        // 5. 保存日志
        saveLog(diff);

        return result;
    }
}
```

### 4.2 Spring Security 原理（中频）

**问题：Spring Security 的工作原理？**

**参考回答**：

```
Spring Security 的核心原理：

1. 过滤器链：
   • Spring Security 本质是一组过滤器链
   • 每个过滤器负责不同的功能
   • 请求会依次经过所有过滤器

2. 核心过滤器：
   • SecurityContextPersistenceFilter：加载 SecurityContext
   • UsernamePasswordAuthenticationFilter：处理登录
   • FilterSecurityInterceptor：授权检查
   • ExceptionTranslationFilter：异常处理

3. 认证流程：
   • 用户提交用户名密码
   • UsernamePasswordAuthenticationFilter 拦截
   • 调用 AuthenticationManager 认证
   • 认证成功后生成 Authentication
   • 存入 SecurityContext

4. 授权流程：
   • 从 SecurityContext 获取 Authentication
   • 检查用户是否有访问权限
   • 有权限：访问资源
   • 无权限：抛出 AccessDeniedException

5. JWT 集成：
   • 自定义 JWT 过滤器
   • 从请求头提取 Token
   • 解析 Token 获取用户信息
   • 构建 Authentication
   • 存入 SecurityContext
```

### 4.3 MyBatis 原理（低频）

**问题：MyBatis 的执行流程？**

**参考回答**：

```
MyBatis 的执行流程：

1. 加载配置：
   • 读取 mybatis-config.xml
   • 加载 Mapper.xml
   • 解析配置信息

2. SqlSession 创建：
   • SqlSessionFactory 创建 SqlSession
   • SqlSession 包含 Configuration 和 Executor

3. Mapper 代理：
   • MapperProxyFactory 创建 Mapper 代理
   • MapperProxy 拦截方法调用
   • 将方法调用转换为 MappedStatement

4. SQL 执行：
   • Executor 执行 SQL
   • StatementHandler 处理 Statement
   • ParameterHandler 设置参数
   • ResultSetHandler 处理结果

5. 结果映射：
   • 将 ResultSet 映射为 Java 对象
   • 支持简单映射和复杂映射
```

---

## 五、业务理解问题

### 5.1 项目业务（高频）

**问题：项目的业务流程是什么？**

**参考回答**：

```
项目的核心业务流程是招标采购流程管理：

1. 项目立项：
   • 创建项目（国谈/带采/挂网等）
   • 填写项目信息
   • 添加产品列表
   • 上传资料文档
   • 保存草稿或提交审核

2. 审批流程：
   • 提交审核后启动审批流程
   • 系统自动生成待办任务
   • 分配给对应的审批人
   • 审批人可以：通过/拒绝/退回
   • 审批通过后流转到下一节点
   • 所有节点审批通过后项目生效

3. 项目执行：
   • 查看项目详情
   • 管理子流程
   • 更新项目状态
   • 项目结项

4. 数据管理：
   • 产品库：维护产品信息
   • 价格库：管理各省价格
   • 资料库：管理产品资料
   • 自动预警：资料过期提醒
```

### 5.2 待办任务（中频）

**问题：待办任务是如何生成的？**

**参考回答**：

```
待办任务生成机制：

1. 触发时机：
   • 项目提交审核时
   • 审批流程流转时
   • 资料申请提交时

2. 生成规则：
   • 根据流程节点配置
   • 根据负责角色分配
   • 支持按地区分配（R1 角色）

3. 分配策略：
   • 用户分配：直接指定用户
   • 角色分配：分配给角色，该角色所有用户可见
   • 地区分配：根据项目地区分配给对应地区的用户

4. 待办状态：
   • 待开始（状态1）
   • 已完成（状态2）
   • 已取消（状态3）

5. 实现逻辑：
   • 启动流程时调用 generateTodoForApprovalNode
   • 清除之前的待办
   • 创建新待办
   • 设置待办处理人
   • 设置待办类型（审批/完善/上传/改价等）
```

---

## 六、项目难点与解决方案

### 6.1 技术难点

**难点1：OAuth2 集成问题**

```
问题：
Azure AD 回调后无法正确获取用户信息

原因：
• 回调 URL 配置错误
• Token 解析失败
• 用户信息映射错误

解决方案：
1. 检查 OAuth2 配置
   • client-id 和 client-secret 正确
   • redirect-uri 与 Azure AD 配置一致
   • scope 包含必要的权限

2. 处理回调
   • 实现 OAuth2LoginAuthenticationSuccessHandler
   • 从 OidcUser 获取用户信息
   • 提取 email、cwid、roles

3. 生成 JWT
   • 调用本地登录服务
   • 生成 JWT Token
   • 重定向到前端并携带 token

4. 前端处理
   • 从 URL 获取 token
   • 存入 sessionStorage
   • 后续请求携带 token
```

**难点2：AOP 日志事务同步**

```
问题：
操作日志在事务回滚时仍然写入，导致数据不一致

原因：
• AOP 在事务提交前写日志
• 事务回滚后日志已经写入

解决方案：
1. 使用 TransactionSynchronization
   TransactionSynchronizationManager.registerSynchronization(
       new TransactionSynchronization() {
           @Override
           public void afterCommit() {
               // 事务提交后才写日志
               saveLog(logDO);
           }
       }
   );

2. 使用 OperationLogContext
   • 标记跳过日志的 AOP
   • 写日志时设置标记
   • 避免循环写日志
```

**难点3：异步任务异常处理**

```
问题：
异步任务中的异常无法被全局异常处理器捕获

原因：
• 异步任务在独立线程中执行
• 异常不会传播到主线程

解决方案：
1. 异步方法内部捕获异常
   @Async
   public void sendEmailAsync(...) {
       try {
           // 发送邮件
       } catch (Exception e) {
           log.error("邮件发送失败", e);
           // 记录到失败队列表
           saveFailedEmail(...);
       }
   }

2. 使用 Future 获取结果
   @Async
   public Future<String> asyncMethod() {
       // ...
       return new AsyncResult<>("success");
   }

3. 定时任务重试
   • 每天定时检查失败的邮件
   • 自动重新发送
   • 记录发送结果
```

### 6.2 业务难点

**难点1：流程状态管理**

```
问题：
审批流程状态复杂，容易出现状态不一致

原因：
• 流程定义和执行分离
• 待办状态与流程状态不同步
• 并发审批导致状态冲突

解决方案：
1. 状态机设计
   • 使用状态机模式管理流程状态
   • 定义清晰的状态转换规则
   • 禁止非法状态转换

2. 事务控制
   • 整个流程操作在一个事务中
   • 更新流程状态
   • 清除旧待办
   • 创建新待办

3. 乐观锁
   • 使用 version 字段
   • 更新时检查版本
   • 避免并发冲突
```

**难点2：权限控制**

```
问题：
权限控制逻辑复杂，容易遗漏

原因：
• 菜单权限
• 按钮权限
• 数据权限（地区）
• 角色权限

解决方案：
1. 统一权限注解
   @RequireRole({"R0001", "R0003"})
   public Result<String> modifyProject(...) {
       // ...
   }

2. 拦截器统一处理
   • 拦截所有请求
   • 检查方法是否有 @RequireRole 注解
   • 验证用户角色

3. 前端权限控制
   • 登录后获取用户菜单
   • 根据菜单显示/隐藏按钮
   • 后端二次验证（防止绕过）
```

---

## 七、面试技巧

### 7.1 项目介绍技巧

**STAR 法则**：

```
Situation（情境）：项目的背景和目标
Task（任务）：你负责的部分
Action（行动）：你做了什么，怎么做的
Result（结果）：取得了什么成果

示例：
S：拜耳需要一个统一的招标采购管理系统
T：我负责后端开发，实现核心业务模块
A：使用 Spring Boot 3 + MyBatis Plus，
    实现了项目管理、产品管理、价格管理等模块
R：系统已上线，处理 500+ 项目数据，
    响应时间控制在 500ms 以内
```

### 7.2 回答问题技巧

**1. 先总后分**：
```
先给出总体结论，再详细说明

示例：
"我们使用了双重认证机制（总），
  JWT Token 用于日常访问，OAuth2 用于 SSO（分）"
```

**2. 量化成果**：
```
用数据说话，更具说服力

示例：
"系统响应时间控制在 500ms 以内"
"并发支持 100+ QPS"
"处理数据 500+ 条"
```

**3. 突出个人贡献**：
```
明确说明你做了什么

示例：
"我负责后端开发，实现了核心业务模块"
"我设计并实现了操作日志功能"
"我优化了系统性能，响应时间降低了 50%"
```

**4. 诚实回答**：
```
不懂的问题诚实说不会，但表达学习意愿

示例：
"这个问题我没有深入研究过，
  但我觉得可能跟 XXX 有关，
  我会去学习了解一下"
```

### 7.3 常见追问准备

**追问1：为什么选择这个技术而不是那个？**

```
准备理由：
1. 技术优势
2. 团队经验
3. 业务需求
4. 生态成熟度
```

**追问2：如果让你重新设计，你会怎么改进？**

```
准备改进点：
1. 微服务拆分
2. 消息队列引入
3. 缓存优化
4. 监控告警
```

**追问3：遇到的最大困难是什么？**

```
准备案例：
1. 技术难点（如 OAuth2 集成）
2. 业务难点（如流程状态管理）
3. 性能问题（如响应慢）
4. 详细的解决过程
```

---

## 总结

### 面试准备清单

**✅ 技术准备**：
- [ ] 熟悉项目技术栈
- [ ] 理解技术原理
- [ ] 准备技术亮点
- [ ] 思考技术选型理由

**✅ 业务准备**：
- [ ] 理解项目业务流程
- [ ] 明确个人贡献
- [ ] 准备量化成果
- [ ] 思考项目难点

**✅ 沟通准备**：
- [ ] 练习项目介绍
- [ ] 准备常见问题答案
- [ ] 准备追问回答
- [ ] 保持自信态度

### 最后的建议

1. **深入理解项目**：不仅要知道怎么实现，还要知道为什么这样设计
2. **突出个人贡献**：明确说明你负责的部分和解决的问题
3. **量化项目成果**：用数据说话，更具说服力
4. **保持学习态度**：诚实面对不会的问题，表达学习意愿
5. **展示技术热情**：对技术有热情，愿意深入学习

祝你面试顺利！
